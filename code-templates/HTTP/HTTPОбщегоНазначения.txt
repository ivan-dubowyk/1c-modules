
#Область СлужебныйПрограммныйИнтерфейс

// Преобразует переданное значение в JSON-строку.
//
// Параметры:
//  Данные - Структура - данные.
// 
// Возвращаемое значение:
//  Строка - строка в формате JSON.
//
Функция СтрокаJSON(Данные) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Данные,, "ПреобразованиеДанныхJSON", HTTPОбщегоНазначения);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Преобразует строку JSON в структуру.
//
// Параметры:
//	Строка - Строка - строка в формате JSON
//	ИменаСвойствСоЗначениямиДата - Массив из Строка - имена свойств для преобразования в значения типа Дата.
// 
// Возвращаемое значение:
//	Структура - данные из переданной строки:
//   * Поля - Произвольный - произвольные поля данных.
Функция ДанныеJSON(Строка, ИменаСвойствСоЗначениямиДата = Неопределено) Экспорт
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Новый Структура;
	КонецЕсли; 
	
	Если ИменаСвойствСоЗначениямиДата = Неопределено Тогда
		ИменаСвойствСоЗначениямиДата = Новый Массив;
	КонецЕсли; 
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	
	Если ИменаСвойствСоЗначениямиДата.Количество() = 0 Тогда
		Ответ = ПрочитатьJSON(ЧтениеJSON); 
	Иначе
		Ответ = ПрочитатьJSON(ЧтениеJSON, , , , 
			"ВосстановлениеЗначенияДата", HTTPОбщегоНазначения, ,
			ИменаСвойствСоЗначениямиДата);
	КонецЕсли;
	
	Возврат Ответ;
	
КонецФункции

// Cм. метод глобального контекста - ЗаписатьJSON, параметр ИмяФункцииПреобразования.
// 
// Параметры:
//  Свойство - Строка
//  Значение - Произвольный
//  ДополнительныеПараметры - Произвольный
//  Отказ - Булево
// 
// Возвращаемое значение:
//  Строка - Преобразование данных JSON
Функция ПреобразованиеДанныхJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Null") Тогда
		Отказ = Истина;
	ИначеЕсли ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Строка(Значение);
	ИначеЕсли ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Значение)) Тогда
		Если ОбщегоНазначения.ЭтоПеречисление(Значение.Метаданные()) Тогда
			Возврат Строка(Значение);
		Иначе
			Возврат Строка(Значение.УникальныйИдентификатор());
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Обработчик восстановления значения типа Дата при чтении JSON-строки.
// 
// Параметры:
//  Свойство - Строка - имя свойства объекта.
//  Значение - Строка, Число - значение, полученное из JSON-строки.
//  ДополнительныеПараметры - Произвольный - дополнительные параметры обработчика.
// 
// Возвращаемое значение:
//  Дата - восстановленное значение даты.
Функция ВосстановлениеЗначенияДата(Свойство, Значение, ДополнительныеПараметры = Неопределено) Экспорт
	
	// Проверка стандартных значений 2018-01-01T00:00:00, 2018-01-01T00:00:00Z, 2018-01-01T00:00:00+0000
	Если СтрДлина(Значение) <= 24 И Сред(Значение, 5, 1) = "-" И Сред(Значение, 8, 1) = "-" И Сред(Значение, 11, 1) = "T" Тогда
		Возврат XMLЗначение(Тип("Дата"), Значение);
	КонецЕсли; 
	
	// Восстановление даты в формате дд.ММ.гггг
	ЧастиЗначенияДаты = СтрРазделить(Значение, ".");
	Если ЧастиЗначенияДаты.Количество() >= 3 Тогда
		Возврат Дата(Число(ЧастиЗначенияДаты[2]), Число(ЧастиЗначенияДаты[1]), Число(ЧастиЗначенияДаты[0]));
	КонецЕсли;
	
	// Восстановление даты в формате ММ/дд/гггг
	ЧастиЗначенияДаты = СтрРазделить(Значение, "/");
	Если ЧастиЗначенияДаты.Количество() >= 3 Тогда
		Возврат Дата(Число(ЧастиЗначенияДаты[2]), Число(ЧастиЗначенияДаты[0]), Число(ЧастиЗначенияДаты[1]));
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Процедура ЛогироватьHTTPЗапрос(Запрос, Ответ, ДвоичныеДанные = Ложь) Экспорт
	
	Если НЕ HTTPПовтИсп.ЛогироватьЗапросыAPI() Тогда
		Возврат;	
	КонецЕсли;
	
	Описание = ОписаниеЗапроса(Запрос, ДвоичныеДанные) + Символы.ПС + "---" + Символы.ПС + ОписаниеОтвета(Ответ, ДвоичныеДанные);
	ЗаписьЖурналаРегистрации(СобытиеHTTPЗапрос(), УровеньЖурналаРегистрации.Информация,
		Метаданные.HTTPСервисы.API, , Описание);
	
КонецПроцедуры
	
Функция СформироватьТекстОшибки(Запрос = Неопределено, ИнфоОбОшибке = Неопределено) Экспорт
	
	МассивОшибок = Новый Массив;
	
	Если Не ИнфоОбОшибке = Неопределено Тогда
		МассивОшибок.Добавить(СтрШаблон("%1 %2", ИнфоОбОшибке.ИмяМодуля, ИнфоОбОшибке.НомерСтроки));
		МассивОшибок.Добавить(ИнфоОбОшибке.Описание);
	КонецЕсли;
	
	Если Не Запрос = Неопределено Тогда
		Описание = ОписаниеЗапроса(Запрос);
		МассивОшибок.Добавить(Описание);	
	КонецЕсли;
	
	Возврат СтрСоединить(МассивОшибок, Символы.ПС);
	
КонецФункции
	
Процедура ЗаписатьОшибкуВЖурнал(Запрос = Неопределено, ИнфоОбОшибке) Экспорт
	
	Если ТипЗнч(ИнфоОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Описание = СформироватьТекстОшибки(Запрос, ИнфоОбОшибке);
	Иначе
		Описание = ИнфоОбОшибке;
	КонецЕсли;
	ЗаписьЖурналаРегистрации(СобытиеHTTPЗапрос(), УровеньЖурналаРегистрации.Ошибка,
		Метаданные.HTTPСервисы.API, , Описание);
	
КонецПроцедуры
	
// Добавить заголовки данных.
// 
// Параметры:
//  Ответ - HTTPСервисОтвет
Процедура ДобавитьЗаголовкиДанных(Ответ) Экспорт
	
	Заголовки = Ответ.Заголовки;
	
	Заголовки.Вставить("Accept", "application/json");
	Заголовки.Вставить("Accept-Charset", "utf-8");
	Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");	
	Заголовки.Вставить("Cache-Control", "no-cache");
	
КонецПроцедуры

Функция СформироватьОтвет(Запрос, ДанныеОтвета, ЭтоТокен = Ложь) Экспорт
	
	Ответ = Новый HTTPСервисОтвет(ДанныеОтвета.КодОтвета);
	ДобавитьЗаголовкиДанных(Ответ);
		
	Если ЭтоТокен Тогда
		ТелоОтвета = ДанныеОтвета;
	Иначе
		ТелоОтвета = Новый Соответствие;
		ТелоОтвета.Вставить("success", ДанныеОтвета.Успешно);		
		ТелоОтвета.Вставить("message", ДанныеОтвета.ТекстОшибки);		
		Если ЗначениеЗаполнено(ДанныеОтвета.Данные) Тогда
			ТелоОтвета.Вставить("response", ДанныеОтвета.Данные);
		КонецЕсли;
	КонецЕсли;
	
	ДанныеJSON = СтрокаJSON(ТелоОтвета);
	
	Ответ.УстановитьТелоИзСтроки(ДанныеJSON, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
	
	ЛогироватьHTTPЗапрос(Запрос, Ответ);
	
	Возврат Ответ;
 	
 КонецФункции

Функция ПолучитьДанныеИзЗапроса(Запрос) Экспорт
	 
	Результат = Неопределено;
	
	Попытка
		СтрокаJSON = Запрос.ПолучитьТелоКакСтроку();
		Результат = ДанныеJSON(СтрокаJSON, ИменаСвойствСоЗначениямиДата());
		
		ПараметрыЗапроса = HTTPОбщегоНазначения.ПреобразоватьСоответствиеВСтруктуру(Запрос.ПараметрыЗапроса);
		
		Для каждого ИмяСвойства Из ИменаСвойствСоЗначениямиДата() Цикл
			Если ПараметрыЗапроса.Свойство(ИмяСвойства) Тогда
				ПараметрыЗапроса[ИмяСвойства] = ВосстановлениеЗначенияДата(ИмяСвойства, ПараметрыЗапроса[ИмяСвойства]);	
			КонецЕсли;
		КонецЦикла; 
		
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Результат, ПараметрыЗапроса);
		
	Исключение
		
		ЗаписатьОшибкуВЖурнал(Запрос, ИнформацияОбОшибке());
	
	КонецПопытки;
	
	Возврат Результат
	
КонецФункции

Функция ИменаСвойствСоЗначениямиДата()

	МассивСвойств = Новый Массив;
	МассивСвойств.Добавить("period_start");
	
	Возврат МассивСвойств;
		
КонецФункции

// Имя события журнала регистрации.
// 
// Параметры:
//  ВложенноеСобытие - Строка
// 
// Возвращаемое значение:
//  Строка
Функция ИмяСобытия(ВложенноеСобытие) Экспорт
	
	Возврат Метаданные.HTTPСервисы.API.Синоним + ". " + ВложенноеСобытие;
	
КонецФункции

Функция ТекстОшибкиДоступЗапрещен() Экспорт
	
	Возврат НСтр("ru = 'Доступ запрещен'; en = 'Access denied'");	
	
КонецФункции

Функция ШаблонОтвета() Экспорт

	Шаблон = Новый Структура;
	Шаблон.Вставить("Данные", Новый Структура);
	Шаблон.Вставить("ТекстОшибки", "");
	Шаблон.Вставить("КодОтвета", 200);
	Шаблон.Вставить("Успешно", Истина);
		
	Возврат Шаблон;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область Логирование

Функция БазовыйURL(HTTPСервисЗапрос)
	
	БазовыйURL = HTTPСервисЗапрос.Заголовки.Получить("X-Forwarded-Path");
	Если БазовыйURL = Неопределено Тогда
		Возврат НормализоватьАдрес(HTTPСервисЗапрос.БазовыйURL);
	Иначе
		ЧастиАдреса = СтрРазделить(НормализоватьАдрес(HTTPСервисЗапрос.БазовыйURL), "/", Ложь);
		Возврат ЧастиАдреса[0] + "//" + ЧастиАдреса[1] + БазовыйURL;
	КонецЕсли;
	
КонецФункции

Функция НормализоватьАдрес(Адрес)
	
	ЧастиАдреса = СтрРазделить(Адрес, "/", Ложь);
	
	Протокол = СокрЛП(ЧастиАдреса[0]) + "//";
	ЧастиАдреса.Удалить(0);
	
	ЧастиИмени = СтрРазделить(СокрЛП(ЧастиАдреса[0]), ":");
	ЧастиАдреса.Удалить(0);
	ИмяСервера = ЧастиИмени[0];
	ПортСервера = ?(ЧастиИмени.Количество() = 1, "", СокрЛП(ЧастиИмени[1]));
	Если Протокол = "http://" Тогда
		ПортСервера = ?(ПустаяСтрока(ПортСервера) Или ПортСервера = "80", "", ":" + ПортСервера);
	ИначеЕсли Протокол = "https://" Тогда
		ПортСервера = ?(ПустаяСтрока(ПортСервера) Или ПортСервера = "443", "", ":" + ПортСервера);
	Иначе
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неизвестный протокол: %1'", 
			ОбщегоНазначения.КодОсновногоЯзыка()), Протокол);
	КонецЕсли;
	
	Путь = "/" + СтрСоединить(ЧастиАдреса, "/");
	
	Возврат Протокол + ИмяСервера + ПортСервера + Путь;
	
КонецФункции

Функция ОписаниеЗапроса(Запрос, ДвоичныеДанные = Ложь)
	
	ПараметрыЗапроса = Неопределено;
	Если ТипЗнч(Запрос) = Тип("HTTPСервисЗапрос") Тогда
		Если Запрос.ПараметрыЗапроса.Количество() Тогда
			ПараметрыЗапроса = Новый Массив;
			Для Каждого КлючИЗначение Из Запрос.ПараметрыЗапроса Цикл
				ПараметрыЗапроса.Добавить(КлючИЗначение.Ключ + "=" + КодироватьСтроку(
					КлючИЗначение.Значение, СпособКодированияСтроки.КодировкаURL));
			КонецЦикла;
			ПараметрыЗапроса = "?" + СтрСоединить(ПараметрыЗапроса, "&");
		КонецЕсли;
		Адрес = Запрос.HTTPМетод + " " + БазовыйURL(Запрос) + Запрос.ОтносительныйURL + ПараметрыЗапроса;
	Иначе
		Адрес = Запрос.АдресРесурса;
	КонецЕсли;
	
	Заголовки = Новый Массив;
	Для Каждого Заголовок  Из Запрос.Заголовки Цикл
		Заголовки.Добавить( СтрШаблон("%1: %2", Заголовок.Ключ, Заголовок.Значение));
	КонецЦикла;
	
	Если ДвоичныеДанные Тогда
		ТелоЗапроса = ПолучитьBase64СтрокуИзДвоичныхДанных(Запрос.ПолучитьТелоКакДвоичныеДанные());
	Иначе
		ТелоЗапроса = Запрос.ПолучитьТелоКакСтроку();
	КонецЕсли; 
	
	Если СтрДлина(ТелоЗапроса) > 1000 Тогда
		ТелоЗапроса = СтрШаблон(НСтр("ru = '%1...'"), Лев(ТелоЗапроса, 1000));
	КонецЕсли; 
	
	Возврат СтрШаблон(
		"%1
		|%2
		|
		|%3", Адрес, 
		СтрСоединить(Заголовки, Символы.ПС), ТелоЗапроса);
	
КонецФункции

Функция ОписаниеОтвета(Ответ, ДвоичныеДанные = Ложь)
	
	Заголовки = Новый Массив;
	Для Каждого Заголовок  Из Ответ.Заголовки Цикл
		Заголовки.Добавить(СтрШаблон("%1: %2", Заголовок.Ключ, Заголовок.Значение));
	КонецЦикла; 
	
	Если ТипЗнч(Ответ) = Тип("HTTPСервисОтвет") Тогда
		КодСостояния = СтрШаблон("%1 %2", Ответ.КодСостояния, Ответ.Причина);
	Иначе
		КодСостояния = Ответ.КодСостояния
	КонецЕсли; 
	
	Если ДвоичныеДанные Тогда
		ТелоОтвета = ПолучитьBase64СтрокуИзДвоичныхДанных(Ответ.ПолучитьТелоКакДвоичныеДанные());
	Иначе
		ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	КонецЕсли; 

	Если СтрДлина(ТелоОтвета) > 1000 Тогда
		ТелоОтвета = СтрШаблон(НСтр("ru = '%1...'"), Лев(ТелоОтвета, 1000));
	КонецЕсли; 
	
	
	Возврат СтрШаблон(
		"%1
		|%2
		|
		|%3", 
		КодСостояния,
		СтрСоединить(Заголовки, Символы.ПС), Ответ.ПолучитьТелоКакСтроку());
	
КонецФункции

Функция СобытиеHTTPЗапрос()
	
	Возврат ИмяСобытия(НСтр("ru = 'HTTP-запрос'", ОбщегоНазначения.КодОсновногоЯзыка()));
	
КонецФункции

#КонецОбласти

// Переименовывает поля данных ответа по соответствию переименований полей.
// 
// Параметры:
// 	ДанныеОтвета - Структура - данные ответа.
// 	Переименования - Соответствие из КлючИЗначение:
// 	* Ключ - Строка - имя исходного поля.
// 	* Значение  - см. ОписаниеКолонки
// 				- Строка - имя колонки.
// Возвращаемое значение:
// 	см. ПереименоватьСвойства.ДанныеОтвета
Функция ПереименоватьСвойства(ДанныеОтвета, Знач Переименования) Экспорт

	Если ТипЗнч(ДанныеОтвета) = Тип("Массив") Тогда
		Для каждого ЭлементМассива Из ДанныеОтвета Цикл
			ЭлементМассива = ПереименоватьСвойства(ЭлементМассива, Переименования);	
		КонецЦикла;	
	ИначеЕсли ТипЗнч(ДанныеОтвета) = Тип("Структура") Тогда	
		Для Каждого Элемент Из Переименования Цикл
			Если ДанныеОтвета.Свойство(Элемент.Ключ) Тогда
				ЗначениеПереименования = Элемент.Значение; // см. ОписаниеКолонки
				Если ТипЗнч(ЗначениеПереименования) = Тип("Строка") Тогда 
					ИмяПоля = ЗначениеПереименования;
					ТипПоля = Неопределено;
				Иначе
					ИмяПоля = ЗначениеПереименования.Имя;
					ТипПоля = ЗначениеПереименования.Тип;
				КонецЕсли;
				Если ТипПоля <> Неопределено Тогда
					Значение = ЗначениеПоТипу(ТипПоля, ДанныеОтвета[Элемент.Ключ]);
					ДанныеОтвета.Вставить(ИмяПоля, Значение);
				Иначе
					ДанныеОтвета.Вставить(ИмяПоля, ДанныеОтвета[Элемент.Ключ]);
				КонецЕсли; 
				ДанныеОтвета.Удалить(Элемент.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ДанныеОтвета;

КонецФункции

Функция ЗначениеПоТипу(ТипЗначения, Значение)
	
	Если ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
		Возврат Новый УникальныйИдентификатор(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.ТипыУслуг")) Тогда
		Возврат Перечисления.ТипыУслуг.ЗначениеПоИмени(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.ПериодичностьПериодовДействия")) Тогда
		Возврат Перечисления.ПериодичностьПериодовДействия.ЗначениеПоИмени(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.СостоянияПриложений")) Тогда
		Возврат Перечисления.СостоянияПриложений.ЗначениеПоИмени(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.ТипыПодписокСервиса")) Тогда
		Возврат Перечисления.ТипыПодписокСервиса.ЗначениеПоИмени(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.ПраваПользователяПриложения")) Тогда
		Возврат Перечисления.ПраваПользователяПриложения.ЗначениеПоИмени(Значение);
	ИначеЕсли ТипЗначения.СодержитТип(Тип("ПеречислениеСсылка.РолиПользователейАбонентов")) Тогда
		Возврат Перечисления.РолиПользователейАбонентов.ЗначениеПоИмени(Значение);
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции

// Возвращает описание колонки таблицы переименования полей.
// 
// Параметры:
//	Имя - Строка - имя переименования.
//	Тип - ОписаниеТипов - тип значения.
//	
// Возвращаемое значение:
//	Структура:
//	 * Имя - Строка - имя переименования.
//	 * Тип - ОписаниеТипов - тип значения.
Функция ОписаниеКолонки(Имя, Тип) Экспорт

	Возврат Новый Структура("Имя, Тип", Имя, Тип);

КонецФункции

// Массив структур в таблицу значений.
// 
// Параметры:
//  МассивСтруктур - Массив Из Структура:
//   * Поля - Произвольный - поля соответствуют колонкам таблицы.
//  ПереименованияКолонок - Соответствие Из КлючИЗначение:
//   * Ключ - Строка
//   * Значение - см. ОписаниеКолонки
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
//   * Поля - Произвольный - набор колонок, соответствует полям структур массива.
Функция МассивСтруктурВТаблицуЗначений(МассивСтруктур, ПереименованияКолонок = Неопределено) Экспорт

	Результат = Новый ТаблицаЗначений;
	Для Каждого Строка Из МассивСтруктур Цикл
		Для Каждого КлючЗначение Из Строка Цикл
			ТипКолонки = Неопределено;
			Если ПереименованияКолонок <> Неопределено Тогда
				ЗначениеПереименования = ПереименованияКолонок.Получить(КлючЗначение.Ключ);
				Если ЗначениеЗаполнено(ЗначениеПереименования) И ТипЗнч(ЗначениеПереименования) = Тип("Структура") Тогда
					ТипКолонки = ЗначениеПереименования.Тип;
				КонецЕсли;
				Если Результат.Колонки.Найти(КлючЗначение.Ключ) = Неопределено Тогда
					Результат.Колонки.Добавить(КлючЗначение.Ключ, ТипКолонки);
				КонецЕсли;
			КонецЕсли;
			Если ТипКолонки <> Неопределено Тогда
				Строка[КлючЗначение.Ключ] = ЗначениеПоТипу(ТипКолонки, КлючЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(Результат.Добавить(), Строка);
	КонецЦикла;

	Если ПереименованияКолонок <> Неопределено Тогда
		Для Каждого Элемент Из ПереименованияКолонок Цикл
			Если ТипЗнч(Элемент.Значение) = Тип("Строка") Тогда
				ИмяКолонки = Элемент.Значение;
				ТипКолонки = Неопределено;
			Иначе
				ИмяКолонки = Элемент.Значение.Имя;
				ТипКолонки = Элемент.Значение.Тип;
			КонецЕсли;
			Если Результат.Колонки.Найти(Элемент.Ключ) <> Неопределено Тогда
				Колонка = Результат.Колонки[Элемент.Ключ]; // КолонкаТаблицыЗначений
				Колонка.Имя = ИмяКолонки;
			Иначе
				Результат.Колонки.Добавить(ИмяКолонки, ТипКолонки);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Таблица значений в массив структур.
// 
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений:
//   * Поля - Произвольный - произвольный набор полей.
// ПереименованияСвойств - Соответствие из КлючИЗначение:
//   * Ключ - Строка
//   * Значение - см. ОписаниеКолонки
// 
// Возвращаемое значение:
//  Массив Из Структура:
//   * Поля - Произвольный - поля соответствуют колонкам таблицы.
Функция ТаблицаЗначенийВМассивСтруктур(ТаблицаЗначений, ПереименованияСвойств) Экспорт
	
	Результат = Новый Массив;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		Элемент = Новый Структура;
		Для Каждого КлючЗначение Из ПереименованияСвойств Цикл
			Если ТаблицаЗначений.Колонки.Найти(КлючЗначение.Значение.Имя) = Неопределено Тогда
				Продолжить;	
			КонецЕсли;
			
			Значение = Строка[КлючЗначение.Значение.Имя];
			Если КлючЗначение.Значение.Тип.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
				Значение = Строка(Значение);
			ИначеЕсли КлючЗначение.Значение.Тип.СодержитТип(Тип("ТаблицаЗначений")) Тогда	
				Значение = ТаблицаЗначенийВМассивСтруктур(Значение, ПереименованияСвойств);	
			КонецЕсли; 
			Элемент.Вставить(КлючЗначение.Ключ, Значение);
		КонецЦикла; 
		Результат.Добавить(Элемент);
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

// Создает структуру, ключами которого являются ключи соответствия.
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура - 
//
//@skip-warning
Функция ПреобразоватьСоответствиеВСтруктуру(Соответствие) Экспорт
	
	Результат = Новый Структура;
	
	Если НЕ ТипЗнч(Соответствие) = Тип("Соответствие")
		И НЕ ТипЗнч(Соответствие) = Тип("ФиксированноеСоответствие") Тогда
		Возврат Результат
	КонецЕсли; 
	
	Для Каждого Элемент Из Соответствие Цикл
		Результат.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции


#КонецОбласти

